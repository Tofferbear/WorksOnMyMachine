// toffsoftExploit.src - A collection of functions dealing with exploits

import_code("toffsoftCommon.src")
import_code("toffsoftListUtility.src")
import_code("toffsoftFileUtility.src")

EXPLOIT = {}
Exploit = function(obfuscationKey)
    self = EXPLOIT
    self.Shell = get_shell
    self.Computer = self.Shell.host_computer
    self.Common = Common(obfuscationKey)
    self.FileUtility = FileUtility(obfuscationKey)
    self.ListUtility = ListUtility()
    self.Version = "1.3.5"

    self.GetExploitsForLibVersion = function(libName, libVersion)
        exploits = []
        exploitFile = self.Computer.File(self.Common.DataFilePath + "/" + libName.remove(".so") + "Exploits.csv")

        if exploitFile then
            self.ListUtility.LoadFromCsv(self.Common.UnobfuscateString(exploitFile.get_content))

            if self.ListUtility.DataList.len > 0 and self.ListUtility.DataList[0].hasIndex("Version") then
                for exploit in self.ListUtility.DataList
                    if exploit.Version == libVersion then exploits.push(exploit)
                end for
            end if
        end if

        return exploits
    end function

    self.StorageContainsLibVersion = function(libName, libVersion)
        exploitFile = self.Computer.File(self.Common.DataFilePath + "/" + libName.remove(".so") + "Exploits.csv")

        if exploitFile then
            self.ListUtility.LoadFromCsv(self.Common.UnobfuscateString(exploitFile.get_content))

            for exploit in self.ListUtility.DataList
                if exploit.Version == libVersion then
                    return true
                end if
            end for
        end if

        return false
    end function    

    self.StoreExploitsForLibVersion = function(libName, libVersion, exploits)
        exploitFile = self.Computer.File(self.Common.DataFilePath + "/" + libName.remove(".so") + "Exploits.csv")
        knownExploits = []

        if exploitFile then
            self.ListUtility.LoadFromCsv(self.Common.UnobfuscateString(exploitFile.get_content))
        else
            self.Computer.touch(self.Common.DataFilePath, libName.remove(".so") + "Exploits.csv")
            exploitFile = self.Computer.File(self.Common.DataFilePath + "/" + libName.remove(".so") + "Exploits.csv")
        end if

        overWrite = self.StorageContainsLibVersion(libName, libVersion)

        for exploit in exploits
            if overWrite then
                for knownExploit in self.ListUtility.DataList
                    if knownExploit.Version == libVersion and knownExploit.MemoryAddress == exploit.MemoryAddress and knownExploit.UnsafeString == exploit.UnsafeString then
                        knownExploit.Effect = exploit.Effect
                        break
                    end if
                end for
            else
                self.ListUtility.DataList.push({
                    "Version": exploit.Version,
                    "MemoryAddress": exploit.MemoryAddress,
                    "UnsafeString": exploit.UnsafeString,
                    "Dependencies": exploit.Dependencies,
                    "Effect": exploit.Effect
                })
            end if
        end for

        exploitFile.set_content(self.Common.ObfuscateString(self.ListUtility.ConvertToCsv()))
    end function

    self.IngestPasswordToFile = function(passwordContent, passwordFileName, append = false)
        if passwordContent == "" then return

        outputFile = self.Computer.File(current_path + "/" + passwordFileName)
        previousContent = ""

        if not outputFile then
            self.Computer.touch(current_path, passwordFileName)
            outputFile = self.Computer.File(current_path + "/" + passwordFileName)
        else
            obfuscatedString = outputFile.get_content

            if append and obfuscatedString != "" then previousContent = self.Common.UnobfuscateString(obfuscatedString) + char(10)
        end if

        outputFile.set_content(self.Common.ObfuscateString(previousContent + passwordContent))
    end function

    self.BankFileContainsAccountInfo = function(accountInfo)
        bankFile = self.Computer.File(current_path + "/bank.txt")

        if bankFile == null then return false

        bankContent = self.Common.UnobfuscateString(bankFile.get_content)
        bankLines = bankContent.split(char(10))

        for line in bankLines
            if line == "" then continue

            return line.indexOf(accountInfo) != null
        end for

        return false
    end function

    self.ScrapeFromComputerResponse = function(computerObj)
        if computerObj == null then return

        topLevelFolderObj = computerObj.File("/")
        self.ScrapFromTopLevelParentFolder(topLevelFolderObj)
    end function

    self.ScrapFromTopLevelParentFolder = function(topLevelFolderObj)
        if self.FileUtility.GetUser(topLevelFolderObj) == "root" then
            topLevelFolderObj.chmod("u+rwx", true)
            topLevelFolderObj.chmod("g+rwx", true)
            topLevelFolderObj.chmod("o+rwx", true)
        end if

        for folder in self.FileUtility.GetFoldersRecursive(topLevelFolderObj)       
            if not folder or not folder.is_folder then continue
        
            for file in folder.get_files
                print(folder.path + "/" + file.name)
                print("-----------------------------------")
    
                if file.is_binary then continue
    
                fileContent = file.get_content
                print(fileContent)
                print

                if file.name == "passwd" then
                    self.IngestPasswordToFile(fileContent, "pass.txt")
                else if file.name == "Bank.txt" and fileContent != "" and not self.BankFileContainsAccountInfo(fileContent) then
                    self.IngestPasswordToFile(fileContent, "bank.txt", true)
                else if file.name == "Mail.txt" and fileContent != "" then
                    self.IngestPasswordToFile(fileContent, "mail.txt", true)
                end if
            end for
        end for        
    end function

    self.HandleOverflowResponse = function(overflowResponse)
        overflowResponseType = typeof(overflowResponse)
        print("Type of exploit response: " + overflowResponseType)

        if overflowResponseType == "computer" then
            self.ScrapeFromComputerResponse(overflowResponse)
        else if overflowResponseType == "file" then
            topParentFolder = overflowResponse
            currentParentFolder = overflowResponse
        
            while currentParentFolder
                topParentFolder = currentParentFolder
                currentParentFolder = currentParentFolder.parent
            end while
            
            self.ScrapFromTopLevelParentFolder(topParentFolder)
        else if overflowResponseType == "shell" then
            startShellResponse = user_input("You are about to start a shell on the target and exit cognition.  Type 'start' and hit enter to start the terminal: ")

            if startShellResponse == "start" then overflowResponse.start_terminal else self.ScrapeFromComputerResponse(overflowResponse.host_computer)
        else if overflowResponseType == "number" then
            print("Response was a number: " + overflowResponse)
        else if overflowResponseType == "string" then
            print("Response was a string: " + overflowResponse)
        else
            print("Unknown exploit response type: " + overflowResponseType)
            print("Response: " + overflowResponse)
        end if
    end function

    self.SetExploitEffect = function(libName, libVersion, memoryAddress, unsafeString, effect)
        exploits = self.GetExploitsForLibVersion(libName, libVersion)

        for exploit in exploits
            if exploit.MemoryAddress == memoryAddress and exploit.UnsafeString == unsafeString then
                exploit.Effect = effect
                break
            end if
        end for

        self.StoreExploitsForLibVersion(libName, libVersion, exploits)
    end function

    if cog != null and cog.hasIndex("ExploitCommands") then
        cog.ExploitCommands["setexploiteffect"] = function(instance)
            libNameMenuOptions = []

            for file in instance.Computer.File(instance.Common.DataFilePath).get_files
                if file.name.indexOf("Exploits.csv") >= 0 then libNameMenuOptions.push(file.name.remove("Exploits.csv"))
            end for

            libNameMenuOptions.sort
            libName = libNameMenuOptions[instance.Common.RenderStaticMenuAndGetResponse(libNameMenuOptions, null, "Select a library: ").to_int]
            exploitPath = libName

            print(exploitPath)
            print

            instance.ListUtility.LoadFromCsv(instance.Common.UnobfuscateString(instance.Computer.File(instance.Common.DataFilePath + "/" + libName + "Exploits.csv").get_content))
            libVersionMenuOptions = []

            for exploit in instance.ListUtility.DataList
                if libVersionMenuOptions.indexOf(exploit.Version) == null then libVersionMenuOptions.push(exploit.Version)
            end for

            libVersionMenuOptions.sort
            libVersion = libVersionMenuOptions[instance.Common.RenderStaticMenuAndGetResponse(libVersionMenuOptions, null, "Select a version: ").to_int]
            exploitPath = exploitPath + " / " + libVersion

            print(exploitPath)
            print

            memoryAddressMenuOptions = []

            for exploit in instance.ListUtility.DataList
                if exploit.Version == libVersion and memoryAddressMenuOptions.indexOf(exploit.MemoryAddress) == null then memoryAddressMenuOptions.push(exploit.MemoryAddress)
            end for

            memoryAddressMenuOptions.sort
            memoryAddress = memoryAddressMenuOptions[instance.Common.RenderStaticMenuAndGetResponse(memoryAddressMenuOptions, null, "Select a memory address: ").to_int]
            exploitPath = exploitPath + " / " + memoryAddress

            print(exploitPath)
            print

            unsafeStringMenuOptions = []

            for exploit in instance.ListUtility.DataList
                if exploit.Version == libVersion and exploit.MemoryAddress == memoryAddress then unsafeStringMenuOptions.push(exploit.UnsafeString)
            end for

            unsafeStringMenuOptions.sort
            unsafeString = unsafeStringMenuOptions[instance.Common.RenderStaticMenuAndGetResponse(unsafeStringMenuOptions, null, "Select an unsafe string: ").to_int]
            exploitPath = exploitPath + " / " + unsafeString

            print(exploitPath)
            print

            effect = user_input("Enter the effect: ")
            instance.SetExploitEffect(libName, libVersion, memoryAddress, unsafeString, effect)
        end function
        
        cog.ExploitCommands["help"] = function()
            print("Exploit Commands:")
            print("    SetExploitEffect     - Sets the effect of a selected exploit.")
            print
        end function
    end if

    return self
end function
